一、默写：
  1.线程的声明周期（5种状态及特征）

  2.使用不同的方法，创建两条线程，两条线程的功能分别是输出从1~10和从1~20

二、回顾：
  1.进程和线程：
	进程包含线程

  2.进程的特点：
	独立性、动态性、并发性

  3.线程的特点：
	资源共享，一个程序可以同时完成多个功能

  4.线程实现：
	1）继承Thread类
	2）实现Runnable接口，需要借助Thread类的构造方法将实现类对象封装成线程

  5.临界资源：（共享的资源）
	会造成线程安全问题
	加锁：将临界资源锁定在操作的线程上

  6.锁定临界资源：
	1）同步代码块
	synchronized
	2）同步方法
	3）ReentranLock
		lock和unlock方法
	注意：在完成临街资源操作之后，必须进行解锁操作（unlock方法）


三、多线程编程的缺点：
	加重CPU的负担
	降低每条线程执行的几率
	线程安全
	死锁

  1.死锁：
	程序设计过程中，避免出现死锁现象
	相当于是两只小羊过独木桥
	在同步代码快中需要使用锁，在两条线程中，每条线程都需要两个所对象，由于线程执行抢占式，当第一条线程a获取到第一把锁s1时，失去时间片，等待另一把锁s2，另一条线程b抢到时间片执行，b获取到s2，b失去时间片，等待s1

  2.使线程进入阻塞挂起状态的方法：
	sleep：使线程进入挂起状态，但是线程自己会醒来（自动进入就绪状态）

	wait：此方法是正在执行的线程进入挂起状态，而且使用此方法挂起的线程自己不会醒来，需要唤醒

	使用notify方法或notifyAll方法将wait等待的线程唤醒

	生产者消费者模式：
	设计思想：
	有一个仓库，存储产品，当仓库没有产品时，消费者不能消费产品，此时需要生产者生产产品，当仓库有产品时，消费者可以消费产品，此时生产者不需要生产产品

	设计核心：有一个对是否需要生产的判断，当需要生产时，生产者工作，消费者闲着，当不需要生产时，生产者闲着，消费者消费

	将生产者和消费者看做是两条线成，当需要生产时，消费者线程不能执行，当不需要生产时，生产者不能执行

	生产者或者消费者挂起时，不能确定何时继续执行
	可以使用wait方法将线程挂起
	当消费者将产品消费之后，唤醒生产者（notify方法）

	对象调用wait方法（对象是锁对象）

	注意：使用wait方法和notify方法时，用那个对象挂起的线程就需要使用那个对象唤醒


四、单例模式中的线程安全问题：
	1.饿汉式不存在现在线程安全问题
	2.懒汉的线程安全
	
public class Singleton{
	private static Singleton s;
	private Singleton(){}
	public static Singleton getS (){
		synchronized(""){
			if(s==null){
				s = new Singleton();
			}
		}
		return s;
	}
}
















