一、默写
	设计一个Person类：有姓名、性别、年龄属性；
	重写toString()方法
	在测试类中创建三个Person类的对象，
	将这三个对象固化到D:\\PersonInfo.txt文件中
	再将数据从文件中读取出来，将三个对象信息打印出来

二、回顾：
  1.抽象类：InputStream、OutputStream、Reader、Writer
	
  2.非抽象类
	字节流
	FileInputStream：read方法（读取一个字节，多个字节存在一个字节数组中）
	FileOutputStream：write方法（写入一个字节，写入一个字节数组）

	字符流
	FileReader：（读取一个字符，读取字符数组）
	FileWriter：（写入一个字符，写入一个字符串）

	缓冲字节流
	BufferedInputStream：
	BufferedOutputStream：

	缓冲字符流
	BufferedReader：readLine方法（读取整行文本，不包括行结束符）
	BufferedWriter：newLine方法，写入一个转行符

	转换流
	将字节流转换成字符流使用
	InputStreamReader：可以指定编码格式读取文件
	OutputStreamWriter：可以指定编码格式写入文件

	对象流
	ObjectInputStream：反序列化
	ObjecOutputStream：序列化
	若想序列化对象，必须实现java.io.Serializable接口
	若不实现则抛出NotSerializableException异常

	序列化和反序列化之间，不可以对类进行任何的修改

  3.流和集合的配合使用:
	Properties集合（键值对）
	load和store

	将多个对象序列化到一个文件中，可以将多个对象存入集合中，再将集合对象序列化
	

三、进程和线程：
  1.进程：
	进程是对资源利用的一个描述
	正在执行的一个程序就是进程

  2.进程的特点：
	独立性：进程和进程之间相互不影响，资源不共享
	动态性：所有的进程都是动态，而不是静止的
	并发性：一个操作系统可以同时运行多个程序

  3.线程：
	在一个进程中，可以完成多个不同的功能，每一个功能完成时相对不影响
	完成某一个特定的功能

  4.线程的特点：
	线程的资源是共享的
	一个进程中至少要有一条线程

  5.进程和线程的关系：
	进程中包含线程，一个进程中至少有一条线程，可以有多条线程

	例：酷狗音乐
	360安全卫士：多个功能相当于是多条线程

  6.线程执行的方式：
	线程的执行不是同时的，抢占式执行，CPU的时间片，不同的线程有自己的时间片时间，线程启动之后等待自己的时间片，当等到时间片时，这条线程就执行
	正在执行的线程随时有可能失去时间片，失去时间片之后继续等待
	正在等待的线程也随时可能获得时间片，开始执行

  7.多线程编程：
	相比多线程编程，多进程编程比较复杂，先耗时间和资源
	优点：资源共享，在一个程序中同时完成多个功能
		java中内置了对多线程编程的机制，简化了多线程编程

	缺点：加大了CPU的负担
		降低了每一条线程的执行几率
		线程安全问题
		死锁现象

  8.线程的生命周期：
	生命周期：从出现到消失
	人：婴儿、幼儿、少儿、少年、青年、中年、老年、晚年、死

	线程的生命周期：（五种状态）
	新建态：此时线程刚刚被创建，没有CPU的使用权
	就绪态：此时线程具有CPU的使用权，相当于被启动，在就绪队列中等待时间片的到来
	运行态：此时线程具有CPU使用权，而且等到了时间片，正在完成自己的功能
	阻塞/挂起态：此时线程失去了CPU的使用权，此时的线程一定是被执行过，但是由于其他原因使得线程挂起
	消亡态：线程执行结束，完成功能

	生命周期的状态转换图

四、线程的实现：
  1.java面向对象，所以在jdk中对线程也进行了封装
	Thread类：线程类
	自定义线程类，继承Thread类

	Thread类中的成员：
	currentThread方法：获取当前正在执行的线程
	run方法是线程的功能
	注意：启动一条线程不可以直接调用线程对象的run方法
	start启动线程

	getName方法获取想成的名称
	setName方法修改线程的名称

	在原来没接触线程时，一个程序中存不存在线程

	线程的优先级：
	不表示线程的执行顺序，表示线程的执行几率
	getPriority：获取线程的优先级
	setPriority：修改线程的优先级

	线程休眠：
	sleep方法：使正在执行的线程休眠指定毫秒数的时间


	了解：

	线程等待：
	join方法：在一个线程a中调用另一个线程b的join方法，表示a线程等待b线程执行完成之后在执行


	守护线程（后台线程）：
	使用setDaemon方法将某一条线程设置成后台线程
		当参数是true时，表示此线程设置成了后台线程
		当参数为false时，表示此线程设置成非后台线程

	使用isDaemon方法测试一个线程是否是守护线程

	线程让步：
	yeild方法：和sleep方法类似，使正在执行的线程暂停一下，让其他线程执行

  2.实现Runnable接口：
	Thread类也是实现了Runnable接口的，run方法的来源是Runnable接口
	
	自定义类，实现Runnable接口，重写run方法
	Runnable接口的实现类不是线程类，没有线程的成员方法
	但是实现类具有线程的功能方法run方法

	需要通过Thread类的构造方法将实现类封装成线程


  3.两种方式的优缺点：
	1）继承Thread类，直观，可扩展性差
	2）实现Runnable接口，不直观，扩展性强

	建议使用实现Runnable，但是两种方法都可以完成一个线程的创建

五、线程同步：
  1.线程同步不是执行同步，而是资源同步（资源共享）

  2.共享资源：（临界资源）
	案例：设计三个窗口卖50张票

	线程安全问题：由于所有的线程都可以对临街资源进行访问并操作，当一条线程对临街资源操作后没有提交，另一条线程又对临界资源进行操作，此时临界资源数据会出现问题

	处理线程安全问题：
	将临界资源锁定在正在操作的线程上

  3.如何将临界资源锁定在正在操作的线程上：
	使用到synchronized关键字

	锁定使用锁
	锁：对象锁和类锁

	一切皆对象，任何对象都可以作为锁

	1）同步代码块：
	语法：
	synchronized(锁){
		//对临街资源进行操作的代码
	}

	注意：虽然任何对都可以作为锁，但是必须保证所有的锁是同个锁对象

	2）同步方法：
	public synchronized void fun(){}

	同步方法就是将同步代码快中的代码放进一个方法中

	建议是同步代码块

	3）同步锁：ReenTrantLock类

	lock方法：加锁
	unlock方法：解锁
	注意使用同步锁时，对临界资源操作完成后必须解锁











